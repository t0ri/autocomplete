class t{constructor(t){this.character=t,this.children={},this.terminal=!1}isTerminal(){return this.terminal}childrenCount(){return Object.keys(this.children).length}hasChild(t){return t in this.children}getChild(t){if(this.hasChild(t))return this.children[t];throw new Error("No child exists for character "+t)}addChild(t,i){if(this.hasChild(t))throw new Error("Child already exists for character "+t);this.children[t]=i}}class i{constructor(i){this.root=new t(""),this.stringCount=0,this.nodeCount=0,i&&i.forEach(t=>this.insert(t))}isEmpty(){return 0===this.stringCount}contains(t){const i=this.findNode(t)[0];return!(!i||!i.terminal)}insert(i){if(!this.contains(i)){let r=this.root;[...i].forEach(i=>{r.hasChild(i)||(r.addChild(i,new t(i)),this.nodeCount+=1),r=r.getChild(i)}),this.stringCount+=1,r.terminal=!0}}findNode(t){if(0===t.length)return this.root,0;let i=this.root,r=0;return[...t].forEach(e=>i.hasChild(e)?(i=i.getChild(e),r!==t.length||i.terminal?void(r+=1):[i,r]):r),[i,r]}complete(t=""){if(""===t)return this.strings();const i=[],r=this.findNode(t)[0];return!this.isEmpty()&&r&&this.traverse(r,t,i.push.bind(i)),i}strings(){const t=[];return this.traverse(this.root,"",t.push.bind(t)),t}traverse(t,i,r){t.terminal&&r(i),Object.keys(t.children).forEach(e=>{const s=t.getChild(e);this.traverse(s,i+e,r)})}}export default class{constructor(t,r,e=!0){this.trie=new i,this.autocompleteCount=r,this.ignoreCasing=e,t&&this.addEntries(t)}get entries(){return this.trie.stringCount}get entriesCharCount(){return this.trie.nodeCount}autocomplete(t=""){return this.ignoreCasing&&(t=t.toLowerCase()),this.autocompleteCount?this.trie.complete(t).slice(0,this.autocompleteCount):this.trie.complete(t)}addEntry(t){t&&(this.ignoreCasing?this.trie.insert(t.toLowerCase()):this.trie.insert(t))}addEntries(t){t&&(this.ignoreCasing?t.forEach(t=>{"string"==typeof t&&this.addEntry(t.toLowerCase())}):t.forEach(t=>{this.addEntry(t)}))}}
